<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Out of the Tar Pit Section 2: Complexity </title>
    <meta name="author" content="Ben Moseley and Peter Marks"/>
    <meta name="keywords" content="Complexity, SoftwareEngineering, RelationalModel, Functional, FunctionalProgramming"/>
    <meta name="subject" content="Complexity"/>
    <meta content="http://www.w3.org/1999/xhtml; charset=utf-8" http-equiv="Content-Type"/>
    <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
  </head>
  <body>
    <h2 id="section-2">2 Complexity</h2>
    <article>
    <p>
      In his classic paper — “No Silver Bullet” Brooks [<a href="references.html#Bro86" class="reference">Bro86</a>] identified four properties of software systems which make building software hard: Complexity, Conformity, Changeability and Invisibility.
      Of these we believe that Complexity is the <em>only</em> significant one — the others can either be <em>classified as</em> forms of complexity, or be seen as problematic solely <em>because</em> of the complexity in the system.
    </p>
    
    <p>
      Complexity is <em>the</em> root cause of the vast majority of problems with software today.
      Unreliability, late delivery, lack of security — often even poor performance in large-scale systems can all be seen as deriving ultimately from unmanageable complexity.
      The primary status of complexity as <em>the</em> major cause of these other problems comes simply from the fact that being able to <em>understand</em> a system is a prerequisite for avoiding all of them, and of course it is this which complexity destroys.
    </p>
    
    <p>
      The relevance of complexity is widely recognised.
      As Dijkstra said [<a href="references.html#Dij97" class="reference">Dij97</a>, EWD1243]
	    <blockquote>
        “…we have to keep it crisp, disentangled, and simple if we refuse to be crushed by the complexities of our own making…”
      </blockquote>
    </p>

    <p>
      …and the Economist devoted a whole article to software complexity [<a href="references.html#Eco04" class="reference">Eco04</a>] — noting that by some estimates software problems cost the American economy $59 billion annually.
    </p>
    
    <p>
      Being able to think and reason about our systems (particularly the effects of changes to those systems) is of <em>crucial</em> importance.
      The dangers of complexity and the importance of simplicity in this regard have also been a popular topic in ACM Turing award lectures.
      In his 1990 lecture Corbato said [<a href="references.html#Cor91" class="reference">Cor91</a>]:
	    <blockquote>
        “The general problem with ambitious systems is complexity.”, “…it is important to emphasize the value of simplicity and elegance, for complexity has a way of compounding difficulties”
      </blockquote>
    </p>

    <p>
      In 1977 Backus [<a href="references.html#Bac78" class="reference">Bac78</a>] talked about the “complexities and weaknesses” of traditional languages and noted:
	    <blockquote>“there is a desperate need for a powerful methodology to help us think about programs. … conventional languages create unnecessary confusion in the way we think about programs”</blockquote>
    </p>

    <p>
      Finally, in his Turing award speech in 1980 Hoare [<a href="references.html#Hoa81" class="reference">Hoa81</a>] observed:
	    <blockquote>
        “…there is one quality that cannot be purchased … — and that is reliability.
        The price of reliability is the pursuit of the utmost simplicity”
      </blockquote>
    </p>

    <p>
      and
	    <blockquote>
        “I conclude that there are two ways of constructing a software design: One way is to make it so simple that there are <em>obviously</em> no deficiencies and the other way is to make it so complicated that there are no <em>obvious</em> deficiencies.
        The first method is far more difficult.”
      </blockquote>
    </p>
    
    <p>
      This is the unfortunate truth:
    </p>
    
    <blockquote class="centred">
      Simplicity is <em>Hard</em>
    </blockquote>
    
    <p>
      …but the purpose of this paper is to give some cause for optimism.
    </p>
    
    <p>
      One final point is that the type of complexity we are discussing in this paper is that which makes large systems <em>hard to understand</em>.  It is this that causes <em>us</em> to expend huge resources in <em>creating and maintaining</em> such systems.
      This type of complexity has nothing to do with complexity theory — the branch of computer science which studies the resources consumed <em>by a machine executing</em> a program.
      The two are completely unrelated — it is a straightforward matter to write a small program in a few lines which is incredibly simple (in our sense) and yet is of the highest complexity class (in the complexity theory sense).
      From this point on we shall only discuss complexity of the first kind.
    </p>
    
    <p>
      We shall look at what we consider to be the major common causes of complexity (things which make understanding difficult) after first discussing exactly how we normally attempt to <em>understand</em> systems.
    </p>
    </article>
  </body>
</html>
